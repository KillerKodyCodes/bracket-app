'use strict'

const { test } = require('tap')
const rfdc = require('..')
const cloneDefault = require('../default')
const clone = rfdc()
const cloneProto = rfdc({ proto: true })
const cloneCircles = rfdc({ circles: true })
const cloneCirclesProto = rfdc({ circles: true, proto: true })

const rnd = (max) => Math.round(Math.random() * max)

types(clone, 'default')
types(cloneProto, 'proto option')
types(cloneCircles, 'circles option')
types(cloneCirclesProto, 'circles and proto option')

test('default – does not copy proto properties', async ({ is }) => {
  is(clone(Object.create({ a: 1 })).a, undefined, 'value not copied')
})
test('default – shorthand import', async ({ same }) => {
  same(
    clone(Object.create({ a: 1 })),
    cloneDefault(Object.create({ a: 1 })),
    'import equals clone with default options'
  )
})
test('proto option – copies enumerable proto properties', async ({ is }) => {
  is(cloneProto(Object.create({ a: 1 })).a, 1, 'value copied')
})
test('circles option - circular object', async ({ same, is, isNot }) => {
  const o = { nest: { a: 1, b: 2 } }
  o.circular = o
  same(cloneCircles(o), o, 'same values')
  isNot(cloneCircles(o), o, 'different objects')
  isNot(cloneCircles(o).nest, o.nest, 'different nested objects')
  const c = cloneCircles(o)
  is(c.circular, c, 'circular references point to copied parent')
  isNot(c.circular, o, 'circular references do not point to original parent')
})
test('circles option – deep circular object', async ({ same, is, isNot }) => {
  const o = { nest: { a: 1, b: 2 } }
  o.nest.circular = o
  same(cloneCircles(o), o, 'same values')
  isNot(cloneCircles(o), o, 'different objects')
  isNot(cloneCircles(o).nest, o.nest, 'different nested objects')
  const c = cloneCircles(o)
  is(c.nest.circular, c, 'circular references point to copied parent')
  isNot(
    c.nest.circular,
    o,
    'circular references do not point to original parent'
  )
})
test('circles option alone – does not copy proto properties', async ({
  is
}) => {
  is(cloneCircles(Object.create({ a: 1 })).a, undefined, 'value not copied')
})
test('circles and proto option – copies enumerable proto properties', async ({
  is
}) => {
  is(cloneCirclesProto(Object.create({ a: 1 })).a, 1, 'value copied')
})
test('circles and proto option - circular object', async ({
  same,
  is,
  isNot
}) => {
  const o = { nest: { a: 1, b: 2 } }
  o.circular = o
  same(cloneCirclesProto(o), o, 'same values')
  isNot(cloneCirclesProto(o), o, 'different objects')
  isNot(cloneCirclesProto(o).nest, o.nest, 'different nested objects')
  const c = cloneCirclesProto(o)
  is(c.circular, c, 'circular references point to copied parent')
  isNot(c.circular, o, 'circular references do not point to original parent')
})
test('circles and proto option – deep circular object', async ({
  same,
  is,
  isNot
}) => {
  const o = { nest: { a: 1, b: 2 } }
  o.nest.circular = o
  same(cloneCirclesProto(o), o, 'same values')
  isNot(cloneCirclesProto(o), o, 'different objects')
  isNot(cloneCirclesProto(o).nest, o.nest, 'different nested objects')
  const c = cloneCirclesProto(o)
  is(c.nest.circular, c, 'circular references point to copied parent')
  isNot(
    c.nest.circular,
    o,
    'circular references do not point to original parent'
  )
})
test('circles and proto option – deep circular array', async ({
  same,
  is,
  isNot
}) => {
  const o = { nest: [1, 2] }
  o.nest.push(o)
  same(cloneCirclesProto(o), o, 'same values')
  isNot(cloneCirclesProto(o), o, 'different objects')
  isNot(cloneCirclesProto(o).nest, o.nest, 'different nested objects')
  const c = cloneCirclesProto(o)
  is(c.nest[2], c, 'circular references point to copied parent')
  isNot(c.nest[2], o, 'circular references do not point to original parent')
})
test('custom constructor handler', async ({ same, ok, isNot }) => {
  class Foo {
    constructor (s) {
      this.s = s
    }
  }
  const data = { foo: new Foo('foo') }
  const cloned = rfdc({ constructorHandlers: [[Foo, (o) => new Foo(o.s)]] })(data)
  ok(cloned.foo instanceof Foo)
  same(cloned.foo.s, data.foo.s, 'same values')
  isNot(cloned.foo, data.foo, 'different objects')
})
test('custom RegExp handler', async ({ same, ok, isNot }) => {
  const data = { regex: /foo/ }
  const cloned = rfdc({ constructorHandlers: [[RegExp, (o) => new RegExp(o)]] })(data)
  isNot(cloned.regex, data.regex, 'different objects')
  ok(cloned.regex.test('foo'))
})

function types (clone, label) {
  test(label + ' – number', async ({ is }) => {
    is(clone(42), 42, 'same value')
  })
  test(label + ' – string', async ({ is }) => {
    is(clone('str'), 'str', 'same value')
  })
  test(label + ' – boolean', async ({ is }) => {
    is(clone(true), true, 'same value')
  })
  test(label + ' – function', async ({ is }) => {
    const fn = () => {}
    is(clone(fn), fn, 'same function')
  })
  test(label + ' – async function', async ({ is }) => {
    const fn = async () => {}
    is(clone(fn), fn, 'same function')
  })
  test(label + ' – generator function', async ({ is }) => {
    const fn = function * () {}
    is(clone(fn), fn, 'same function')
  })
  test(label + ' – date', async ({ is, isNot }) => {
    const date = new Date()
    is(+clone(date), +date, 'same value')
    isNot(clone(date), date, 'different object')
  })
  test(label + ' – null', async ({ is }) => {
    is(clone(null), null, 'same value')
  })
  test(label + ' – shallow object', async ({ same, isNot }) => {
    const o = { a: 1, b: 2 }
    same(clone(o), o, 'same values')
    isNot(clone(o), o, 'different object')
  })
  test(label + ' – shallow array', async ({ same, isNot }) => {
    const o = [1, 2]
    same(clone(o), o, 'same values')
    isNot(clone(o), o, 'different arrays')
  })
  test(label + ' – deep object', async ({ same, isNot }) => {
    const o = { nest: { a: 1, b: 2 } }
    same(clone(o), o, 'same values')
    isNot(clone(o), o, 'different objects')
    isNot(clone(o).nest, o.nest, 'different nested objects')
  })
  test(label + ' – deep array', async ({ same, isNot }) => {
    const o = [{ a: 1, b: 2 }, [3]]
    same(cl